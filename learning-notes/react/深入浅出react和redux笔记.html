<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第二章 设计高质量的react组件 | BLOG</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="Curriculum Vitae">
    <link rel="preload" href="/assets/css/0.styles.5ce1744f.css" as="style"><link rel="preload" href="/assets/js/app.5229a9c5.js" as="script"><link rel="preload" href="/assets/js/2.d0c61049.js" as="script"><link rel="preload" href="/assets/js/27.c73a140c.js" as="script"><link rel="prefetch" href="/assets/js/10.01fd0c45.js"><link rel="prefetch" href="/assets/js/11.e59609e1.js"><link rel="prefetch" href="/assets/js/12.b28e5429.js"><link rel="prefetch" href="/assets/js/13.2720234c.js"><link rel="prefetch" href="/assets/js/14.0b33dd18.js"><link rel="prefetch" href="/assets/js/15.e4cad622.js"><link rel="prefetch" href="/assets/js/16.407e4663.js"><link rel="prefetch" href="/assets/js/17.7fe2abee.js"><link rel="prefetch" href="/assets/js/18.64d40d69.js"><link rel="prefetch" href="/assets/js/19.ae3ca64a.js"><link rel="prefetch" href="/assets/js/20.09a4c0e4.js"><link rel="prefetch" href="/assets/js/21.5646fdcd.js"><link rel="prefetch" href="/assets/js/22.aff186f1.js"><link rel="prefetch" href="/assets/js/23.c419c197.js"><link rel="prefetch" href="/assets/js/24.0bf626b6.js"><link rel="prefetch" href="/assets/js/25.b988f897.js"><link rel="prefetch" href="/assets/js/26.f1f04fec.js"><link rel="prefetch" href="/assets/js/28.f429846b.js"><link rel="prefetch" href="/assets/js/29.4cf38d3d.js"><link rel="prefetch" href="/assets/js/3.1b1aead2.js"><link rel="prefetch" href="/assets/js/30.f2c011aa.js"><link rel="prefetch" href="/assets/js/31.fc83628d.js"><link rel="prefetch" href="/assets/js/32.e8d14d93.js"><link rel="prefetch" href="/assets/js/4.dc1b9d45.js"><link rel="prefetch" href="/assets/js/5.d8b7d05d.js"><link rel="prefetch" href="/assets/js/6.58321c59.js"><link rel="prefetch" href="/assets/js/7.32db407e.js"><link rel="prefetch" href="/assets/js/8.0b662fca.js"><link rel="prefetch" href="/assets/js/9.54be5433.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5ce1744f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">BLOG</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/learning-notes/" class="nav-link router-link-active">
  技术
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试题
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://github.com/keFei1996" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/learning-notes/" class="nav-link router-link-active">
  技术
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试题
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://github.com/keFei1996" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>微信小程序</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node.js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>React</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learning-notes/react/深入浅出react和redux笔记.html" class="active sidebar-link">第二章 设计高质量的react组件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning-notes/react/深入浅出react和redux笔记.html#第二章-设计高质量的react组件" class="sidebar-link">第二章 设计高质量的react组件</a></li><li class="sidebar-sub-header"><a href="/learning-notes/react/深入浅出react和redux笔记.html#第五章-react组件的性能优化" class="sidebar-link">第五章 react组件的性能优化</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>插件</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="第二章-设计高质量的react组件"><a href="#第二章-设计高质量的react组件" class="header-anchor">#</a> 第二章 设计高质量的react组件</h2> <h3 id="props和pros验证"><a href="#props和pros验证" class="header-anchor">#</a> props和pros验证</h3> <p>style的值有两层花括号，外层花括号代表是jsx的语法，内层的花括号代表这是一个对象常量。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code> <span class="token operator">&lt;</span>Counter onUpdate<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>onCounterUpdate<span class="token punctuation">}</span> caption<span class="token operator">=</span><span class="token string">&quot;First&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>Counter onUpdate<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>onCounterUpdate<span class="token punctuation">}</span> caption<span class="token operator">=</span><span class="token string">&quot;Second&quot;</span> initValue<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>initValues<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>Counter onUpdate<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>onCounterUpdate<span class="token punctuation">}</span> caption<span class="token operator">=</span><span class="token string">&quot;Third&quot;</span> initValue<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>initValues<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 在子组件中进行props 验证</span>
Counter<span class="token punctuation">.</span>propTypes <span class="token operator">=</span> <span class="token punctuation">{</span>
  caption<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>string<span class="token punctuation">.</span>isRequired<span class="token punctuation">,</span>
  initValue<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>number<span class="token punctuation">,</span>
  onUpdate<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>func
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>也可以给props设置默认值</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="prop-和state的对比"><a href="#prop-和state的对比" class="header-anchor">#</a> prop 和state的对比</h3> <ul><li>prop 用于定义外部的接口，state用于记录内部的状态</li> <li>prop 的赋值在外部世界使用组件时，state的赋值在组件内部，</li> <li>组件不应该改变prop的值，而state存在的目的就是让组件来改变的</li> <li>组件的state修改 使用 setstate
注意：组件不能去修改传入的props的值，
一个子组件不能修改props的值。</li></ul> <h3 id="组件的声明周期"><a href="#组件的声明周期" class="header-anchor">#</a> 组件的声明周期</h3> <p>分为三个大的过程</p> <ul><li>装载过程</li> <li>更新过程</li> <li>卸载过程</li></ul> <h3 id="装载过程-当组件第一次被渲染的时候，依次调用的函数是"><a href="#装载过程-当组件第一次被渲染的时候，依次调用的函数是" class="header-anchor">#</a> 装载过程 当组件第一次被渲染的时候，依次调用的函数是</h3> <ul><li>constructor</li> <li>componentWillmount</li> <li>render</li> <li>componentDidMount</li></ul> <h4 id="constructor"><a href="#constructor" class="header-anchor">#</a> - constructor</h4> <ul><li>初始化state</li> <li>绑定成员函数的this环境</li></ul> <p>在ES6语法下，类的每个成员函数在执行时的this并不是和类实例自动绑定的。而在构造函数中，this就是当前组件实例，所以为了方便将来的调用，往往在构造函数中将这个实例的特定函数绑定this为当前实例。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span>func<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>render 函数不做实际的渲染动作，它只是返回一个JSX描述的结构，最终由react来操作渲染过程。
如果这个组件不需要渲染的话就用render函数返回一个null 或者false</p> <p>componentWillmount会在render函数之前被调用，componentDidMount会在render函数之后被调用，这两个函数就像是render函数的前哨和后哨，一前一后，把render函数夹住，正好分别做render前后的必要工作。</p> <p>componentWillMount 将要装载  这个时候没有人会渲染出来的结果</p> <p>componentDidMount 调用的时候组件已经被装载到DOM树上了。
render函数被调用完之后，componentDidMount函数并不是会被立刻调用，componentDidMount被调用的时候，render函数返回的东西已经引发了渲染，组件已经被‘装载’到了DOM树上。</p> <p>一个例子
渲染三个组件，当所有三个组件的render函数都被调用之后，三个组件的componentDidMount才连在一起被调用。
之所以会出现这种情况，是因为render函数本身并不是一往DOM树上渲染或者装载内容，它只是返回一个JSX表示的对象，然后有react库来根据返回对象决定如何渲染。而react库肯定是吧所有组件返回的结果综合起来，才能知道该如何产生对应的DOM修改。
所以，只有react库调用三个组件的render函数之后，才有可能完成装载。</p> <p>在componentDidMount调用的时候，组件已经被装载到DOM树上了，可以获取渲染出来的任何dom。</p> <h3 id="更新过程"><a href="#更新过程" class="header-anchor">#</a> 更新过程</h3> <ul><li><p>shouldCompontentUpdate</p></li> <li><p>componentWillUpdate</p></li> <li><p>render</p></li> <li><p>componentDidUpdate</p></li> <li><p>shouldCompontentUpdate
而shouldCompontentUpdate 决定了一个组件什么时候不需要渲染，
提高react组件性能。
render 和shouldCompontentUpdate函数，render函数返回结果将用于构建dom对象，shouldCompontentUpdate函数返回的是一个布尔值，告诉react库这个组件在这次更新过程中是否要继续。</p></li></ul> <p>在更新的过程中，react库先调用而shouldCompontentUpdate函数，如果这个函数返回true，那就会继续更新过程，接下来调用reader函数，反之，如果得到的是一个false，那就立刻停止更新过程，也就不会引发后续的渲染了。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code> <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>caption <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>caption<span class="token punctuation">)</span> <span class="token operator">||</span>
           <span class="token punctuation">(</span>nextState<span class="token punctuation">.</span>count <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>shouldCompontentUpdate 接收两个参数nextProps, nextState值，
在通过this.setState函数引发更新过程，并不是立刻更新组件的state值，在执行到函数 shouldComponentUpdate的时候，this.state依然是this.setState函数执行之前的值，所以我们要做的实际上就是在nextProps、nextState、this.props和this.state中互相对比。</p> <ul><li>componentWillUpdate和componentDidUpdate</li></ul> <p>如果shouldCompontentUpdate函数返回的是true，react接下来就会依次调用对应组件的componentWillUpdate、render和componentDidUpdate函数。</p> <h3 id="卸载过程"><a href="#卸载过程" class="header-anchor">#</a> 卸载过程</h3> <p>componentWillUnmount， 当react组件要从dom树上删除掉之前被调用。 这个函数适合做一些清理性工作。</p> <h1 id="redux"><a href="#redux" class="header-anchor">#</a> redux</h1> <p>redux 三个基本原则</p> <ul><li>唯一数据源</li> <li>保持状态只读</li> <li>数据改变只能通过纯函数完成</li></ul> <ol><li><p>唯一数据源
指应用的状态数据应该只存储在唯一的一个store上</p></li> <li><p>保持状态只读
不能直接修改状态，要修改store的状态，必须要通过派发一个action对象完成。
数据改变只能通过纯函数reducer完成</p></li> <li><p>reducer有两个参数是state，action
第一个是当前的状态，第二个是action是接收到的action对象。 reducer函数要做的事情，就是根据state和action的值产生一个新的对象返回，注意reducer必须是纯函数，也就是说函数的返回结果必须完全由参数state和action决定，而且不产生任何副作用，也不会修改参数state和action对象。</p></li></ol> <h3 id="react-redux"><a href="#react-redux" class="header-anchor">#</a> react-redux</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default connect(mapStateToProps, mapDispatchToProps)(EditTable);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>react-redux 的两个主要的功能
connect 连接容器组件和傻瓜组件
provider 提供包含store的context
connect是react-redux提供的方法，这个方法接受两个参数mapStateToProps和 mapDispatch-ToProps，执行结果依然是一个函数，说以才可以在后面又加一个圆括号，把connect函数执行的结果立刻执行，这一次参数是counter这个傻瓜组件。</p> <h3 id="connect"><a href="#connect" class="header-anchor">#</a> connect</h3> <p>这个connect函数具体做了什么工作呢？</p> <ul><li>把store上的状态转化为内层傻瓜组件的prop</li> <li>把内层傻瓜组件中的用户动作转化为派发给store的动作。
这两个工作一个是内层傻瓜对象的输入，一个是内层傻瓜对象的输出。</li></ul> <p>这两个的工作，是把store上的状态转化为内层组件的props，其实就是一个映射关系，去掉框架，最后就是一个mapStateToProps函数该做的事情。</p> <h3 id="provider"><a href="#provider" class="header-anchor">#</a> provider</h3> <h2 id="第五章-react组件的性能优化"><a href="#第五章-react组件的性能优化" class="header-anchor">#</a> 第五章 react组件的性能优化</h2> <p>单个组件的性能优化
react利用虚拟DOM来提高渲染性能，虽然每一次页面更新都是对组件的重新渲染，但是并不是将之前渲染的内容全部抛弃重来，借助虚拟DOM,react能够计算出对dom树的最少修改</p> <p>但是计算虚拟DOM也是一个很复杂的过程。</p> <p>shouldComponentUpdate是默认方式，默认返回true，也就是说默认每次更新的时候都要调用所有的生命周期函数，包括render函数，根据render函数的返回结果计算虚拟dom。</p> <p>就是在编写逻辑的时候返回false。
自己每个组件都写很麻烦，
二react-redux库，</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default connect(mapStateToProps, mapDispatchToProps)(EditTable);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>connect的过程实际上产生了一个无名的react组件类，这个类定制了shouldComponentUpdate函数的实现，实现逻辑是比对这次传递给内层组件的props和上一次的props，她的渲染结果完全由传入的props决定，如果props没有变化，那就可以认为渲染结果肯定一样。</p> <p>问题是react-redux的渲染比较是浅层比较，简单的说如果prop的类型是复杂对象，传入两次相同的props也会从新渲染。</p> <p>为什么是浅层比较
不知道prop是有多少层</p> <h3 id="多个子组件的情况"><a href="#多个子组件的情况" class="header-anchor">#</a> 多个子组件的情况</h3> <p>使用key，给每一个子组件增加一个key属性，且这个key是唯一的，这个key不应该是数组的下标</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/learning-notes/node/node常用的api.html" class="prev">
        Node.js常见API
      </a></span> <span class="next"><a href="/learning-notes/library/私人珍藏插件.html">
        前端常用插件、工具类汇总--私人珍藏
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.5229a9c5.js" defer></script><script src="/assets/js/2.d0c61049.js" defer></script><script src="/assets/js/27.c73a140c.js" defer></script>
  </body>
</html>
